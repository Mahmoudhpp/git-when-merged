#! /usr/bin/python2

# Run "git when-merged --help for the documentation.

"""Find when a commit was merged into one or more branches.

Find the merge commit that brought COMMIT into the specified
BRANCH(es).  Specificially, look for the oldest commit on the
first-parent history of BRANCH that contains the COMMIT as an
ancestor.

"""

USAGE = r"""git when-merged [OPTIONS] COMMIT [BRANCH...]
"""

EPILOG = r"""
  COMMIT
      a commit whose destiny you would like to determine (this
      argument is required)

  BRANCH...
      the destination branches into which <commit> might have been
      merged.  (Actually, BRANCH can be an arbitrary commit, specified
      in any way that is understood by git-rev-parse(1).) If neither
      <branch> nor -p/--pattern nor -s/--default is specified, then
      HEAD is used

Examples:
  git when-merged 0a1b                     # Find merge into current branch
  git when-merged 0a1b feature-1 feature-2 # Find merge into given branches
  git when-merged 0a1b -p feature-[0-9]+   # Specify branches by regex
  git when-merged 0a1b -n releases         # Use whenmerged.releases.pattern
  git when-merged 0a1b -s                  # Use whenmerged.default.pattern

  git when-merged 0a1b -d feature-1        # Show diff for each merge commit
  git when-merged 0a1b -v feature-1        # Display merge commit in gitk

Configuration:
  whenmerged.<name>.pattern
      Regular expressions that match reference names for the pattern
      called <name>.  A regexp is sought in the full reference name,
      in the form "refs/heads/master".  This option can be
      multivalued, in which case references matching any of the
      patterns are considered.  Typically you will use pattern(s) that
      match master and/or significant release branches, or perhaps
      their remote-tracking equivalents.  For example,

          git config whenmerged.default.pattern \
                  '^refs/heads/master$'

      or

          git config whenmerged.releases.pattern \
                  '^refs/remotes/origin/release\-\d+\.\d+$'

Based on:
  http://stackoverflow.com/questions/8475448/find-merge-commit-which-include-a-specific-commit
"""

import sys
import re
import subprocess
import optparse


class Failure(Exception):
    pass


def read_refpatterns(name):
    key = 'whenmerged.%s.pattern' % (name,)
    process = subprocess.Popen(
        ['git', 'config', '--get-all', '--null', key],
        stdout=subprocess.PIPE,
        )
    (out, err) = process.communicate()
    retcode = process.wait()
    if retcode:
        raise Failure('There is no configuration setting for %r!' % (key,))
    retval = []
    for value in out.split('\0'):
        if value:
            try:
                retval.append(re.compile(value))
            except re.error, e:
                sys.stderr.write(
                    'Error compiling branch pattern %r; ignoring: %s\n'
                    % (value, e.message,)
                    )
    return retval


def iter_commit_refs():
    """Iterate over the names of references that refer to commits.

    (This includes references that refer to annotated tags that refer
    to commits.)"""

    process = subprocess.Popen(
        [
            'git', 'for-each-ref',
            '--format=%(refname) %(objecttype) %(*objecttype)',
            ],
        stdout=subprocess.PIPE,
        )
    for line in process.stdout:
        words = line.strip().split()
        refname = words.pop(0)
        if words == ['commit'] or words == ['tag', 'commit']:
            yield refname

    retcode = process.wait()
    if retcode:
        raise Failure('git for-each-ref failed')


def iter_matching_refs(refpatterns):
    for refname in iter_commit_refs():
        for refpattern in refpatterns:
            m = refpattern.search(refname)
            if m:
                yield refname
                break


def rev_parse(arg):
    process = subprocess.Popen(
        ['git', 'rev-parse', '--verify', '--quiet', arg],
        stdout=subprocess.PIPE,
        )
    (out, err) = process.communicate()
    retcode = process.poll()
    if retcode:
        raise Failure('%r is not a valid commit!' % (arg,))
    return out.strip()


def rev_list(*args):
    process = subprocess.Popen(
        ['git', 'rev-list'] + list(args) + ['--'],
        stdout=subprocess.PIPE,
        )
    for line in process.stdout:
        yield line.strip()

    retcode = process.wait()
    if retcode:
        raise Failure('git rev-list %s failed' % (' '.join(args),))


FORMAT = '%(refname)-38s %(msg)s\n'

def find_merge(commit, branch):
    """Return the SHA1 of the commit that merged commit into branch.

    It is assumed that content is always merged in via the second or
    subsequent parents of a merge commit."""

    try:
        branch_sha1 = rev_parse(branch)
    except Failure, e:
        sys.stdout.write(FORMAT % dict(refname=branch, msg='Is not a valid commit!'))
        return None

    branch_commits = set(
        rev_list('--first-parent', branch_sha1, '--not', '%s^@' % (commit,))
        )

    if commit in branch_commits:
        sys.stdout.write(FORMAT % dict(refname=branch, msg='Commit is directly on this branch.'))
        return None

    last = None
    for commit in rev_list('--ancestry-path', '%s..%s' % (commit, branch_sha1,)):
        if commit in branch_commits:
            last = commit

    if not last:
        sys.stdout.write(FORMAT % dict(refname=branch, msg='Does not contain commit.'))
    else:
        sys.stdout.write(FORMAT % dict(refname=branch, msg=last))

    return last


class Parser(optparse.OptionParser):
    """An OptionParser that doesn't reflow usage and epilog."""

    def get_usage(self):
        return self.usage

    def format_epilog(self, formatter):
        return self.epilog


def main(args):
    parser = Parser(
        prog='git when-merged',
        description=__doc__,
        usage=USAGE,
        epilog=EPILOG,
        )

    parser.add_option(
        '--pattern', '-p', metavar='PATTERN',
        action='append', dest='patterns', default=[],
        help=(
            'Show when COMMIT was merged to the references matching '
            'the specified regexp.  If the regexp has parentheses for '
            'grouping, then display in the output the part of the '
            'reference name matching the first group.'
            ),
        )
    parser.add_option(
        '--name', '-n', metavar='NAME',
        action='append', dest='names', default=[],
        help=(
            'Show when COMMIT was merged to the references matching the '
            'configured pattern(s) with the given name (see '
            'CONFIGURATION below).'
            ),
        )
    parser.add_option(
        '--default', '-s',
        action='append_const', dest='names', const='default',
        help='Shorthand for "--name=default".',
        )
    parser.add_option(
        '--diff', '-d', action='store_true', default=False,
        help='Show the diff for the merge commit.',
        )
    parser.add_option(
        '--visualize', '-v', action='store_true', default=False,
        help='Visualize the merge commit using gitk.',
        )

    (options, args) = parser.parse_args(args)

    if not args:
        parser.error('You must specify a COMMIT argument')

    commit = args.pop(0)
    # Convert commit into a SHA1:
    try:
        commit = rev_parse(commit)
    except Failure, e:
        sys.exit(e.message)

    refpatterns = []

    for value in options.patterns:
        try:
            refpatterns.append(re.compile(value))
        except re.error, e:
            sys.stderr.write(
                'Error compiling pattern %r; ignoring: %s\n'
                % (value, e.message,)
                )

    for value in options.names:
        try:
            refpatterns.extend(read_refpatterns(value))
        except Failure, e:
            sys.exit(e.message)

    branches = []

    if refpatterns:
        branches.extend(iter_matching_refs(refpatterns))
    if args:
        branches.extend(args)
    if not branches:
        branches.append('HEAD')

    for branch in branches:
        try:
            merge = find_merge(commit, branch)
        except Failure, e:
            sys.stderr.write('%s\n' % (e.message,))
            continue

        if merge:
            if options.diff:
                subprocess.check_call(['git', 'show', merge])

            if options.visualize:
                subprocess.check_call(['gitk', '--all', '--select-commit=%s' % (merge,)])


main(sys.argv[1:])

